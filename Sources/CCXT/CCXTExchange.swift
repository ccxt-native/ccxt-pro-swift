// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

import Foundation
import CCXTCore

extension Exchange.CCXTError: LocalizedError {
    public var errorDescription: String? {
        switch self {
        case .exchange(let msg):
            return msg                          // show the exchange text
        case .decoding(let err):
            return "JSON decoding failed: \(err.localizedDescription)"
        }
    }
}

public class Exchange {
    private let exchange: CcxtCCXTGoExchange
    
    public init?(exchangeName: String, config: [String: Any]? = nil) {
        let configString: String

        if let config = config,
           let jsonData = try? JSONSerialization.data(withJSONObject: config, options: []),
           let jsonString = String(data: jsonData, encoding: .utf8) {
            configString = jsonString
        } else {
            configString = "{}"
        }
        guard let ex = CcxtNewExchange(exchangeName, configString) else {
            return nil
        }
        self.exchange = ex
    }

    private func cleanAny(_ value: Any) -> Any? {
        switch value {
        case is NSNull:
            return nil
        case let number as NSNumber:
            if CFGetTypeID(number) == CFBooleanGetTypeID() {
                return number.boolValue
            } else {
                return number
            }
        case let dict as [String: Any]:
            var cleaned: [String: Any] = [:]
            for (key, val) in dict {
                if let cleanedVal = cleanAny(val) {
                    cleaned[key] = cleanedVal
                }
            }
            return cleaned
        case let array as [Any]:
            return array.compactMap { cleanAny($0) }
        default:
            return value
        }
    }

    private func stringify<T: Encodable>(_ object: T, prettyPrinted: Bool = false) -> String? {
        let encoder = JSONEncoder()
        if prettyPrinted {
            encoder.outputFormatting = .prettyPrinted
        }

        do {
            let data = try encoder.encode(object)
            return String(data: data, encoding: .utf8)
        } catch {
            print("Failed to stringify object: \(error)")
            return nil
        }
    }
    
    public enum CCXTError: Error {
        case exchange(String)   // message coming back from the Go layer / exchange
        case decoding(Error)    // genuine JSON-decoding problem
    }
    
    private func decode(_ value: Any?) throws -> Any? {
        guard let value = value else {
            return nil
        }

        switch value {
        case let data as Data:
            // Quick check for literal boolean or null
            if var s = String(data: data, encoding: .utf8)?.trimmingCharacters(in: .whitespacesAndNewlines) {
                if s == "true" { return true }
                if s == "false" { return false }
                if s == "null" { return nil }

                // Parse number-like strings
                if let intVal = Int(s) { return intVal }
                if let doubleVal = Double(s) { return doubleVal }
            }

            do {
                // Normal JSON parse
                return try JSONSerialization.jsonObject(with: data, options: [])
            } catch {
                // CCXT panic parsing
                if let s = String(data: data, encoding: .utf8), s.contains("[ccxtError]::[") {
                    let segments = s.components(separatedBy: "::")
                    if segments.count >= 3 {
                        let rawType = segments[1].trimmingCharacters(in: CharacterSet(charactersIn: "[]"))
                        if let jsonStart = s.firstIndex(of: "{"),
                        let jsonEnd = s[jsonStart...].firstIndex(of: "}") {
                            var jsonSubstring = String(s[jsonStart...jsonEnd])
                            jsonSubstring = jsonSubstring.replacingOccurrences(of: "\\\"", with: "\"")
                            if let jsonData = jsonSubstring.data(using: .utf8),
                            let jsonObj = try? JSONSerialization.jsonObject(with: jsonData) as? [String: Any] {
                                let message = (jsonObj["msg"] as? String) ??
                                            (jsonObj["message"] as? String) ??
                                            jsonSubstring
                                if let errorClass = NSClassFromString("CCXTSwift.\(rawType)") as? BaseError.Type {
                                    throw errorClass.init(message)
                                }
                                throw CCXTError.exchange(message)
                            }
                        }

                        let tail = segments.last ?? ""
                        var plainMsg = tail.replacingOccurrences(of: "]\\nStack:\\n\"", with: "")
                        plainMsg = plainMsg.trimmingCharacters(in: CharacterSet(charactersIn: "[]\"\n "))

                        if let errorClass = NSClassFromString("CCXTSwift.\(rawType)") as? BaseError.Type {
                            throw errorClass.init(plainMsg)
                        }
                        throw CCXTError.exchange(plainMsg)
                    }
                }

                // Non-panic string / invalid JSON
                if var s = String(data: data, encoding: .utf8) {
                    // Strip outer quotes and unescape
                    if s.hasPrefix("\"") && s.hasSuffix("\"") {
                        s.removeFirst()
                        s.removeLast()
                        s = s.replacingOccurrences(of: "\\\"", with: "\"")
                        s = s.replacingOccurrences(of: "\\n", with: "\n")
                    }
                    if let intVal = Int(s) { return intVal }
                    if let doubleVal = Double(s) { return doubleVal }
                    return s
                }

                throw CCXTError.decoding(error)
            }

        case let str as String:
            // Numeric conversion
            if let intVal = Int(str) { return intVal }
            if let doubleVal = Double(str) { return doubleVal }
            return str

        case let number as NSNumber:
            if CFGetTypeID(number) == CFBooleanGetTypeID() {
                return number.boolValue
            } else if CFNumberIsFloatType(number) {
                return number.doubleValue
            } else {
                return number.intValue
            }

        case let bool as Bool:
            return bool

        default:
            return value
        }
    }




    // ------------------------------------------------------------------------

    // ########################################################################
    // ########################################################################
    // ########################################################################
    // ########################################################################
    // ########                        ########                        ########
    // ########                        ########                        ########
    // ########                        ########                        ########
    // ########                        ########                        ########
    // ########        ########################        ########################
    // ########        ########################        ########################
    // ########        ########################        ########################
    // ########        ########################        ########################
    // ########                        ########                        ########
    // ########                        ########                        ########
    // ########                        ########                        ########
    // ########                        ########                        ########
    // ########################################################################
    // ########################################################################
    // ########################################################################
    // ########################################################################
    // ########        ########        ########                        ########
    // ########        ########        ########                        ########
    // ########        ########        ########                        ########
    // ########        ########        ########                        ########
    // ################        ########################        ################
    // ################        ########################        ################
    // ################        ########################        ################
    // ################        ########################        ################
    // ########        ########        ################        ################
    // ########        ########        ################        ################
    // ########        ########        ################        ################
    // ########        ########        ################        ################
    // ########################################################################
    // ########################################################################
    // ########################################################################
    // ########################################################################

    // ------------------------------------------------------------------------
    // METHODS BELOW THIS LINE ARE TRANSPILED

    public var isSandboxModeEnabled: Bool {
        get {
            let propValue = try? self.exchange.getIsSandboxModeEnabled()
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! Bool
            return cleaned
        }
        set {
            try? self.exchange.setIsSandboxModeEnabled(newValue as! Bool)
        }
    }

    public var api: [String: Any] {
        get {
            let propValue = try? self.exchange.getApi()
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! [String: Any]
            return cleaned
        }
        
    }

    public var userAgent: String? {
        get {
            let propValue = try? self.exchange.getUserAgent()
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! String?
            return cleaned
        }
        set {
            try? self.exchange.setUserAgent(newValue as! String)
        }
    }

    public var userAgents: [String: String] {
        get {
            let propValue = try? self.exchange.getUserAgents()
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! [String: String]
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setUserAgents(serialized)
        }
    }

    public var returnResponseHeaders: Bool {
        get {
            let propValue = try? self.exchange.getReturnResponseHeaders()
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! Bool
            return cleaned
        }
        set {
            try? self.exchange.setReturnResponseHeaders(newValue as! Bool)
        }
    }

    public var MAX_VALUE: Double {
        get {
            let propValue = try? self.exchange.getMAX_VALUE()
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! Double
            return cleaned
        }
        set {
            try? self.exchange.setMAX_VALUE(newValue as! Double)
        }
    }

    public var substituteCommonCurrencyCodes: Bool {
        get {
            let propValue = try? self.exchange.getSubstituteCommonCurrencyCodes()
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! Bool
            return cleaned
        }
        set {
            try? self.exchange.setSubstituteCommonCurrencyCodes(newValue as! Bool)
        }
    }

    public var reduceFees: Bool {
        get {
            let propValue = try? self.exchange.getReduceFees()
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! Bool
            return cleaned
        }
        set {
            try? self.exchange.setReduceFees(newValue as! Bool)
        }
    }

    public func setTimeout(newValue: Int64) {
        try? self.exchange.setTimeout(newValue as! Int64)
    }

    public func setVerbose(newValue: Bool) {
        try? self.exchange.setVerbose(newValue as! Bool)
    }

    public func setTwofa(newValue: String) {
        try? self.exchange.setTwofa(newValue as! String)
    }

    public var balance: Any {
        get {
            let propValue = try? self.exchange.getBalance()
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! Any
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setBalance(serialized)
        }
    }

    public var liquidations: [String: [String: Any]] {
        get {
            let propValue = try? self.exchange.getLiquidations()
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! [String: [String: Any]]
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setLiquidations(serialized)
        }
    }

    public var orderbooks: [String: [String: Any]] {
        get {
            let propValue = try? self.exchange.getOrderbooks()
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! [String: [String: Any]]
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setOrderbooks(serialized)
        }
    }

    public var tickers: [String: [String: Any]] {
        get {
            let propValue = try? self.exchange.getTickers()
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! [String: [String: Any]]
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setTickers(serialized)
        }
    }

    public var fundingRates: [String: [String: Any]] {
        get {
            let propValue = try? self.exchange.getFundingRates()
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! [String: [String: Any]]
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setFundingRates(serialized)
        }
    }

    public var bidsasks: [String: [String: Any]] {
        get {
            let propValue = try? self.exchange.getBidsasks()
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! [String: [String: Any]]
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setBidsasks(serialized)
        }
    }

    public var orders: Any {
        get {
            let propValue = try? self.exchange.getOrders()
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! Any
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setOrders(serialized)
        }
    }

    public var triggerOrders: Any {
        get {
            let propValue = try? self.exchange.getTriggerOrders()
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! Any
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setTriggerOrders(serialized)
        }
    }

    public var transactions: [String: [String: Any]] {
        get {
            let propValue = try? self.exchange.getTransactions()
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! [String: [String: Any]]
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setTransactions(serialized)
        }
    }

    public var myLiquidations: [String: [String: Any]] {
        get {
            let propValue = try? self.exchange.getMyLiquidations()
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! [String: [String: Any]]
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setMyLiquidations(serialized)
        }
    }

    public var precision: [String: Any]? {
        get {
            let propValue = try? self.exchange.getPrecision()
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! [String: Any]?
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setPrecision(serialized)
        }
    }

    public var last_http_response: Any {
        get {
            let propValue = try? self.exchange.getLast_http_response()
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! Any
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setLast_http_response(serialized)
        }
    }

    public var last_request_headers: [String: String] {
        get {
            let propValue = try? self.exchange.getLast_request_headers()
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! [String: String]
            return cleaned
        }
        
    }

    public var last_request_body: Any {
        get {
            let propValue = try? self.exchange.getLast_request_body()
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! Any
            return cleaned
        }
        
    }

    public var last_request_url: String {
        get {
            let propValue = try? self.exchange.getLast_request_url()
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! String
            return cleaned
        }
        
    }

    public var lastRequestBody: Any {
        get {
            let propValue = try? self.exchange.getLastRequestBody()
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! Any
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setLastRequestBody(serialized)
        }
    }

    public var lastRequestUrl: String {
        get {
            let propValue = try? self.exchange.getLastRequestUrl()
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! String
            return cleaned
        }
        set {
            try? self.exchange.setLastRequestUrl(newValue as! String)
        }
    }

    public var id: String {
        get {
            let propValue = try? self.exchange.getId()
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! String
            return cleaned
        }
        
    }

    public var markets: [String: Any] {
        get {
            let propValue = try? self.exchange.getMarkets()
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! [String: Any]
            return cleaned
        }
        
    }

    public var features: [String: [String: Any]] {
        get {
            let propValue = try? self.exchange.getFeatures()
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! [String: [String: Any]]
            return cleaned
        }
        
    }

    public var rateLimit: Double {
        get {
            let propValue = try? self.exchange.getRateLimit()
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! Double
            return cleaned
        }
        set {
            try? self.exchange.setRateLimit(newValue as! Double)
        }
    }

    public var tokenBucket: [String: Double] {
        get {
            let propValue = try? self.exchange.getTokenBucket()
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! [String: Double]
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setTokenBucket(serialized)
        }
    }

    public var throttler: Any {
        get {
            let propValue = try? self.exchange.getThrottler()
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! Any
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setThrottler(serialized)
        }
    }

    public func setEnableRateLimit(newValue: Bool) {
        try? self.exchange.setEnableRateLimit(newValue as! Bool)
    }

    public var httpExceptions: [String: Any] {
        get {
            let propValue = try? self.exchange.getHttpExceptions()
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! [String: Any]
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setHttpExceptions(serialized)
        }
    }

    public var limits: [String: Any]? {
        get {
            let propValue = try? self.exchange.getLimits()
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! [String: Any]?
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setLimits(serialized)
        }
    }

    public var markets_by_id: [String: Any] {
        get {
            let propValue = try? self.exchange.getMarkets_by_id()
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! [String: Any]
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setMarkets_by_id(serialized)
        }
    }

    public var symbols: Strings {
        get {
            let propValue = try? self.exchange.getSymbols()
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! Strings
            return cleaned
        }
        
    }

    public var ids: Strings {
        get {
            let propValue = try? self.exchange.getIds()
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! Strings
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setIds(serialized)
        }
    }

    public var currencies: [String: Any] {
        get {
            let propValue = try? self.exchange.getCurrencies()
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! [String: Any]
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setCurrencies(serialized)
        }
    }

    public var baseCurrencies: [String: [String: Any]] {
        get {
            let propValue = try? self.exchange.getBaseCurrencies()
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! [String: [String: Any]]
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setBaseCurrencies(serialized)
        }
    }

    public var quoteCurrencies: [String: [String: Any]] {
        get {
            let propValue = try? self.exchange.getQuoteCurrencies()
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! [String: [String: Any]]
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setQuoteCurrencies(serialized)
        }
    }

    public var currencies_by_id: [String: [String: Any]] {
        get {
            let propValue = try? self.exchange.getCurrencies_by_id()
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! [String: [String: Any]]
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setCurrencies_by_id(serialized)
        }
    }

    public var codes: Strings {
        get {
            let propValue = try? self.exchange.getCodes()
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! Strings
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setCodes(serialized)
        }
    }

    public func setAccounts(newValue: [[String: Any]]) {
        let serialized = try? JSONSerialization.data(withJSONObject: newValue)
        try? self.exchange.setAccounts(serialized)
    }

    public var accountsById: [String: [String: Any]] {
        get {
            let propValue = try? self.exchange.getAccountsById()
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! [String: [String: Any]]
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setAccountsById(serialized)
        }
    }

    public var commonCurrencies: [String: String] {
        get {
            let propValue = try? self.exchange.getCommonCurrencies()
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! [String: String]
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setCommonCurrencies(serialized)
        }
    }

    public var hostname: String? {
        get {
            let propValue = try? self.exchange.getHostname()
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! String?
            return cleaned
        }
        
    }

    public var exceptions: [String: String] {
        get {
            let propValue = try? self.exchange.getExceptions()
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! [String: String]
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setExceptions(serialized)
        }
    }

    public var timeframes: Any {
        get {
            let propValue = try? self.exchange.getTimeframes()
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! Any
            return cleaned
        }
        
    }

    public var version: String? {
        get {
            let propValue = try? self.exchange.getVersion()
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! String?
            return cleaned
        }
        
    }

    public var name: String? {
        get {
            let propValue = try? self.exchange.getName()
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! String?
            return cleaned
        }
        set {
            try? self.exchange.setName(newValue as! String)
        }
    }

    public var httpProxyAgentModule: Any {
        get {
            let propValue = try? self.exchange.getHttpProxyAgentModule()
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! Any
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setHttpProxyAgentModule(serialized)
        }
    }

    public var httpsProxyAgentModule: Any {
        get {
            let propValue = try? self.exchange.getHttpsProxyAgentModule()
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! Any
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setHttpsProxyAgentModule(serialized)
        }
    }

    public var socksProxyAgentModule: Any {
        get {
            let propValue = try? self.exchange.getSocksProxyAgentModule()
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! Any
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setSocksProxyAgentModule(serialized)
        }
    }

    public var socksProxyAgentModuleChecked: Bool {
        get {
            let propValue = try? self.exchange.getSocksProxyAgentModuleChecked()
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! Bool
            return cleaned
        }
        set {
            try? self.exchange.setSocksProxyAgentModuleChecked(newValue as! Bool)
        }
    }

    public var proxyDictionaries: [String: Any] {
        get {
            let propValue = try? self.exchange.getProxyDictionaries()
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! [String: Any]
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setProxyDictionaries(serialized)
        }
    }

    public var alias: Bool {
        get {
            let propValue = try? self.exchange.getAlias()
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! Bool
            return cleaned
        }
        
    }

    public var clients: [String: Any] {
        get {
            let propValue = try? self.exchange.getClients()
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! [String: Any]
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setClients(serialized)
        }
    }

    public var newUpdates: Bool {
        get {
            let propValue = try? self.exchange.getNewUpdates()
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! Bool
            return cleaned
        }
        set {
            try? self.exchange.setNewUpdates(newValue as! Bool)
        }
    }

    public var options: [String: Any] {
        get {
            let propValue = try? self.exchange.getOptions()
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! [String: Any]
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setOptions(serialized)
        }
    }

    public func setApiKey(newValue: String) {
        try? self.exchange.setApiKey(newValue as! String)
    }

    public func setSecret(newValue: String) {
        try? self.exchange.setSecret(newValue as! String)
    }

    public func setUid(newValue: String) {
        try? self.exchange.setUid(newValue as! String)
    }

    public var login: String {
        get {
            let propValue = try? self.exchange.getLogin()
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! String
            return cleaned
        }
        set {
            try? self.exchange.setLogin(newValue as! String)
        }
    }

    public func setPassword(newValue: String) {
        try? self.exchange.setPassword(newValue as! String)
    }

    public func setPrivateKey(newValue: String) {
        try? self.exchange.setPrivateKey(newValue as! String)
    }

    public func setWalletAddress(newValue: String) {
        try? self.exchange.setWalletAddress(newValue as! String)
    }

    public var token: String {
        get {
            let propValue = try? self.exchange.getToken()
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! String
            return cleaned
        }
        set {
            try? self.exchange.setToken(newValue as! String)
        }
    }

    public var trades: [String: Any] {
        get {
            let propValue = try? self.exchange.getTrades()
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! [String: Any]
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setTrades(serialized)
        }
    }

    public var ohlcvs: [String: [String: Any]] {
        get {
            let propValue = try? self.exchange.getOhlcvs()
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! [String: [String: Any]]
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setOhlcvs(serialized)
        }
    }

    public var myTrades: Any {
        get {
            let propValue = try? self.exchange.getMyTrades()
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! Any
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setMyTrades(serialized)
        }
    }

    public var positions: Any {
        get {
            let propValue = try? self.exchange.getPositions()
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! Any
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setPositions(serialized)
        }
    }

    public var has: Any {
        get {
            let propValue = try? self.exchange.getHas()
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! Any
            return cleaned
        }
        
    }

    public var urls: [String: Any] {
        get {
            let propValue = try? self.exchange.getUrls()
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! [String: Any]
            return cleaned
        }
        
    }

    public var requiredCredentials: [String: Any] {
        get {
            let propValue = try? self.exchange.getRequiredCredentials()
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! [String: Any]
            return cleaned
        }
        
    }

    public var fees: [String: Any] {
        get {
            let propValue = try? self.exchange.getFees()
            let jsonObject = try! self.decode(propValue)
            let cleaned = self.cleanAny(jsonObject)! as! [String: Any]
            return cleaned
        }
        set {
            let serialized = try? JSONSerialization.data(withJSONObject: newValue)
            try? self.exchange.setFees(serialized)
        }
    }

    public func loadMarkets (reload: Bool = false, params: [String: Any] = [:]) async throws -> [String: [String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: [String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.loadMarkets(reload, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: [String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchCurrencies (params: [String: Any] = [:]) async throws -> [String: [String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: [String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchCurrencies(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: [String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchMarkets (params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchMarkets(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func setSandboxMode (enabled: Bool) throws -> Void {
        
                    
                    try self.exchange.setSandboxMode(enabled)
                
    }


    public func fetchAccounts (params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchAccounts(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchTrades (symbol: String, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchTrades(symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchTradesWs (symbol: String, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchTradesWs(symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func watchLiquidations (symbol: String, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.watchLiquidations(symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func watchLiquidationsForSymbols (symbols: [String], since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
					let symbols_string = symbols.joined(separator: ",")
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.watchLiquidations(forSymbols: symbols_string, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func watchMyLiquidations (symbol: String, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.watchMyLiquidations(symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func watchMyLiquidationsForSymbols (symbols: [String], since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
					let symbols_string = symbols.joined(separator: ",")
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.watchMyLiquidations(forSymbols: symbols_string, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func watchTrades (symbol: String, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.watchTrades(symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func unWatchOrders (symbol: String? = nil, params: [String: Any] = [:]) async throws -> Any {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Any, Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.unWatchOrders(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! Any)
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func unWatchTrades (symbol: String, params: [String: Any] = [:]) async throws -> Any {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Any, Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.unWatchTrades(symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! Any)
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func watchTradesForSymbols (symbols: [String], since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
					let symbols_string = symbols.joined(separator: ",")
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.watchTrades(forSymbols: symbols_string, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func unWatchTradesForSymbols (symbols: [String], params: [String: Any] = [:]) async throws -> Any {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Any, Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					let symbols_string = symbols.joined(separator: ",")
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.unWatchTrades(forSymbols: symbols_string, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! Any)
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func watchOrdersForSymbols (symbols: [String], since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
					let symbols_string = symbols.joined(separator: ",")
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.watchOrders(forSymbols: symbols_string, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func watchOrderBookForSymbols (symbols: [String], limit: Int? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (limit != nil) { paramsCopy["limit"] = limit }
					let symbols_string = symbols.joined(separator: ",")
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.watchOrderBook(forSymbols: symbols_string, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func unWatchOrderBookForSymbols (symbols: [String], params: [String: Any] = [:]) async throws -> Any {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Any, Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					let symbols_string = symbols.joined(separator: ",")
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.unWatchOrderBook(forSymbols: symbols_string, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! Any)
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func unWatchPositions (symbols: Strings = nil, params: [String: Any] = [:]) async throws -> Any {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Any, Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbols != nil) { paramsCopy["symbols"] = symbols }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.unWatchPositions(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! Any)
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchDepositAddresses (codes: Strings = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (codes != nil) { paramsCopy["codes"] = codes }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchDepositAddresses(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchOrderBook (symbol: String, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchOrderBook(symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchOrderBookWs (symbol: String, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchOrderBookWs(symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchMarginMode (symbol: String, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchMarginMode(symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchMarginModes (symbols: Strings = nil, params: [String: Any] = [:]) async throws -> [String: [String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: [String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbols != nil) { paramsCopy["symbols"] = symbols }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchMarginModes(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: [String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func watchOrderBook (symbol: String, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.watchOrderBook(symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func unWatchOrderBook (symbol: String, params: [String: Any] = [:]) async throws -> Any {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Any, Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.unWatchOrderBook(symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! Any)
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchTime (params: [String: Any] = [:]) async throws -> Int? {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Int?, Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchTime(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! Int?)
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchTradingLimits (symbols: Strings = nil, params: [String: Any] = [:]) async throws -> Any {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Any, Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbols != nil) { paramsCopy["symbols"] = symbols }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchTradingLimits(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! Any)
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchCrossBorrowRates (params: [String: Any] = [:]) async throws -> [String: [String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: [String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchCrossBorrowRates(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: [String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchIsolatedBorrowRates (params: [String: Any] = [:]) async throws -> [String: [String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: [String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchIsolatedBorrowRates(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: [String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchLeverageTiers (symbols: Strings = nil, params: [String: Any] = [:]) async throws -> [String: [[String: Any]]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: [[String: Any]]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbols != nil) { paramsCopy["symbols"] = symbols }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchLeverageTiers(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: [[String: Any]]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchFundingRates (symbols: Strings = nil, params: [String: Any] = [:]) async throws -> [String: [String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: [String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbols != nil) { paramsCopy["symbols"] = symbols }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchFundingRates(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: [String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchFundingIntervals (symbols: Strings = nil, params: [String: Any] = [:]) async throws -> [String: [String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: [String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbols != nil) { paramsCopy["symbols"] = symbols }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchFundingIntervals(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: [String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func transfer (code: String, amount: Double, fromAccount: String, toAccount: String, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.transfer(code, amount: amount, fromAccount: fromAccount, toAccount: toAccount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func withdraw (code: String, amount: Double, address: String, tag: String? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (tag != nil) { paramsCopy["tag"] = tag }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.withdraw(code, amount: amount, address: address, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createDepositAddress (code: String, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.createDepositAddress(code, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func setLeverage (leverage: Int, symbol: String? = nil, params: [String: Any] = [:]) async throws -> Any {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Any, Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.setLeverage(leverage, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! Any)
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchLeverage (symbol: String, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchLeverage(symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchLeverages (symbols: Strings = nil, params: [String: Any] = [:]) async throws -> [String: [String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: [String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbols != nil) { paramsCopy["symbols"] = symbols }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchLeverages(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: [String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func setPositionMode (hedged: Bool, symbol: String? = nil, params: [String: Any] = [:]) async throws -> Any {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Any, Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.setPositionMode(hedged, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! Any)
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func addMargin (symbol: String, amount: Double, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.addMargin(symbol, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func reduceMargin (symbol: String, amount: Double, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.reduceMargin(symbol, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func setMargin (symbol: String, amount: Double, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.setMargin(symbol, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchLongShortRatio (symbol: String, timeframe: String? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (timeframe != nil) { paramsCopy["timeframe"] = timeframe }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchLongShortRatio(symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchLongShortRatioHistory (symbol: String? = nil, timeframe: String? = nil, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
					if (timeframe != nil) { paramsCopy["timeframe"] = timeframe }
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchLongShortRatioHistory(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchMarginAdjustmentHistory (symbol: String? = nil, type: String? = nil, since: Double? = nil, limit: Double? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
					if (type != nil) { paramsCopy["type"] = type }
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchMarginAdjustmentHistory(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func setMarginMode (marginMode: String, symbol: String? = nil, params: [String: Any] = [:]) async throws -> Any {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Any, Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.setMarginMode(marginMode, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! Any)
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchDepositAddressesByNetwork (code: String, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchDepositAddresses(byNetwork: code, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchOpenInterestHistory (symbol: String, timeframe: String = "1h", since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchOpenInterestHistory(symbol, timeframe: timeframe, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchOpenInterest (symbol: String, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchOpenInterest(symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchOpenInterests (symbols: Strings = nil, params: [String: Any] = [:]) async throws -> [String: [String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: [String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbols != nil) { paramsCopy["symbols"] = symbols }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchOpenInterests(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: [String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func signIn (params: [String: Any] = [:]) async throws -> Any {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Any, Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.sign(in: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! Any)
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchBorrowRate (code: String, amount: Double, params: [String: Any] = [:]) async throws -> Any {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Any, Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchBorrowRate(code, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! Any)
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func repayCrossMargin (code: String, amount: Double, params: [String: Any] = [:]) async throws -> Any {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Any, Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.repayCrossMargin(code, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! Any)
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func repayIsolatedMargin (symbol: String, code: String, amount: Double, params: [String: Any] = [:]) async throws -> Any {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Any, Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.repayIsolatedMargin(symbol, code: code, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! Any)
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func borrowCrossMargin (code: String, amount: Double, params: [String: Any] = [:]) async throws -> Any {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Any, Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.borrowCrossMargin(code, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! Any)
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func borrowIsolatedMargin (symbol: String, code: String, amount: Double, params: [String: Any] = [:]) async throws -> Any {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Any, Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.borrowIsolatedMargin(symbol, code: code, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! Any)
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func borrowMargin (code: String, amount: Double, symbol: String? = nil, params: [String: Any] = [:]) async throws -> Any {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Any, Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.borrowMargin(code, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! Any)
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchOHLCV (symbol: String, timeframe: String = "1m", since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[Double]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[Double]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchOHLCV(symbol, timeframe: timeframe, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[Double]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchOHLCVWs (symbol: String, timeframe: String = "1m", since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[Double]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[Double]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchOHLCVWs(symbol, timeframe: timeframe, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[Double]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func watchOHLCV (symbol: String, timeframe: String = "1m", since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[Double]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[Double]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.watchOHLCV(symbol, timeframe: timeframe, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[Double]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchL2OrderBook (symbol: String, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchL2OrderBook(symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func editOrder (id: String, symbol: String, type: OrderType, side: OrderSide, amount: Double? = nil, price: Double? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (amount != nil) { paramsCopy["amount"] = amount }
					if (price != nil) { paramsCopy["price"] = price }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.editOrder(id, symbol: symbol, typeVar: type, side: side, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func editOrderWs (id: String, symbol: String, type: OrderType, side: OrderSide, amount: Double? = nil, price: Double? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (amount != nil) { paramsCopy["amount"] = amount }
					if (price != nil) { paramsCopy["price"] = price }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.editOrderWs(id, symbol: symbol, typeVar: type, side: side, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchPosition (symbol: String, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchPosition(symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchPositionWs (symbol: String, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchPositionWs(symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func watchPosition (symbol: String? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.watchPosition(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func watchPositions (symbols: Strings = nil, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbols != nil) { paramsCopy["symbols"] = symbols }
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.watchPositions(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchPositionsForSymbol (symbol: String, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchPositions(forSymbol: symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchPositionsForSymbolWs (symbol: String, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchPositions(forSymbolWs: symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchPositions (symbols: Strings = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbols != nil) { paramsCopy["symbols"] = symbols }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchPositions(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchPositionsWs (symbols: Strings = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbols != nil) { paramsCopy["symbols"] = symbols }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchPositionsWs(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchPositionsRisk (symbols: Strings = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbols != nil) { paramsCopy["symbols"] = symbols }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchPositionsRisk(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchBidsAsks (symbols: Strings = nil, params: [String: Any] = [:]) async throws -> [String: [String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: [String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbols != nil) { paramsCopy["symbols"] = symbols }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchBidsAsks(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: [String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchBorrowInterest (code: String? = nil, symbol: String? = nil, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (code != nil) { paramsCopy["code"] = code }
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchBorrowInterest(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchLedger (code: String? = nil, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (code != nil) { paramsCopy["code"] = code }
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchLedger(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchLedgerEntry (id: String, code: String? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (code != nil) { paramsCopy["code"] = code }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchLedgerEntry(id, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchBalance (params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchBalance(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchBalanceWs (params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchBalanceWs(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func watchBalance (params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.watchBalance(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchStatus (params: [String: Any] = [:]) async throws -> Any {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Any, Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchStatus(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! Any)
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchTransactionFee (code: String, params: [String: Any] = [:]) async throws -> Any {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Any, Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchTransactionFee(code, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! Any)
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchTransactionFees (codes: Strings = nil, params: [String: Any] = [:]) async throws -> Any {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Any, Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (codes != nil) { paramsCopy["codes"] = codes }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchTransactionFees(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! Any)
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchDepositWithdrawFee (code: String, params: [String: Any] = [:]) async throws -> Any {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Any, Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchDepositWithdrawFee(code, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! Any)
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchCrossBorrowRate (code: String, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchCrossBorrowRate(code, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchIsolatedBorrowRate (symbol: String, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchIsolatedBorrowRate(symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchTicker (symbol: String, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchTicker(symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchTickerWs (symbol: String, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchTickerWs(symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func watchTicker (symbol: String, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.watchTicker(symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchTickers (symbols: Strings = nil, params: [String: Any] = [:]) async throws -> [String: [String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: [String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbols != nil) { paramsCopy["symbols"] = symbols }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchTickers(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: [String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchMarkPrices (symbols: Strings = nil, params: [String: Any] = [:]) async throws -> [String: [String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: [String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbols != nil) { paramsCopy["symbols"] = symbols }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchMarkPrices(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: [String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchTickersWs (symbols: Strings = nil, params: [String: Any] = [:]) async throws -> [String: [String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: [String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbols != nil) { paramsCopy["symbols"] = symbols }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchTickersWs(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: [String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchOrderBooks (symbols: Strings = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [String: [String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: [String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbols != nil) { paramsCopy["symbols"] = symbols }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchOrderBooks(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: [String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func watchBidsAsks (symbols: Strings = nil, params: [String: Any] = [:]) async throws -> [String: [String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: [String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbols != nil) { paramsCopy["symbols"] = symbols }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.watchBidsAsks(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: [String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func watchTickers (symbols: Strings = nil, params: [String: Any] = [:]) async throws -> [String: [String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: [String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbols != nil) { paramsCopy["symbols"] = symbols }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.watchTickers(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: [String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func unWatchTickers (symbols: Strings = nil, params: [String: Any] = [:]) async throws -> Any {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Any, Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbols != nil) { paramsCopy["symbols"] = symbols }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.unWatchTickers(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! Any)
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchOrder (id: String, symbol: String? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchOrder(id, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchOrderWs (id: String, symbol: String? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchOrderWs(id, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createOrder (symbol: String, type: OrderType, side: OrderSide, amount: Double, price: Double? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (price != nil) { paramsCopy["price"] = price }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.createOrder(symbol, typeVar: type, side: side, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchConvertTrade (id: String, code: String? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (code != nil) { paramsCopy["code"] = code }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchConvertTrade(id, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchConvertTradeHistory (code: String? = nil, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (code != nil) { paramsCopy["code"] = code }
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchConvertTradeHistory(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchPositionMode (symbol: String? = nil, params: [String: Any] = [:]) async throws -> Any {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Any, Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchPositionMode(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! Any)
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createTrailingAmountOrder (symbol: String, type: OrderType, side: OrderSide, amount: Double, price: Double? = nil, trailingAmount: Double? = nil, trailingTriggerPrice: Double? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (price != nil) { paramsCopy["price"] = price }
					if (trailingAmount != nil) { paramsCopy["trailingAmount"] = trailingAmount }
					if (trailingTriggerPrice != nil) { paramsCopy["trailingTriggerPrice"] = trailingTriggerPrice }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.createTrailingAmountOrder(symbol, typeVar: type, side: side, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createTrailingAmountOrderWs (symbol: String, type: OrderType, side: OrderSide, amount: Double, price: Double? = nil, trailingAmount: Double? = nil, trailingTriggerPrice: Double? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (price != nil) { paramsCopy["price"] = price }
					if (trailingAmount != nil) { paramsCopy["trailingAmount"] = trailingAmount }
					if (trailingTriggerPrice != nil) { paramsCopy["trailingTriggerPrice"] = trailingTriggerPrice }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.createTrailingAmountOrderWs(symbol, typeVar: type, side: side, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createTrailingPercentOrder (symbol: String, type: OrderType, side: OrderSide, amount: Double, price: Double? = nil, trailingPercent: Double? = nil, trailingTriggerPrice: Double? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (price != nil) { paramsCopy["price"] = price }
					if (trailingPercent != nil) { paramsCopy["trailingPercent"] = trailingPercent }
					if (trailingTriggerPrice != nil) { paramsCopy["trailingTriggerPrice"] = trailingTriggerPrice }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.createTrailingPercentOrder(symbol, typeVar: type, side: side, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createTrailingPercentOrderWs (symbol: String, type: OrderType, side: OrderSide, amount: Double, price: Double? = nil, trailingPercent: Double? = nil, trailingTriggerPrice: Double? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (price != nil) { paramsCopy["price"] = price }
					if (trailingPercent != nil) { paramsCopy["trailingPercent"] = trailingPercent }
					if (trailingTriggerPrice != nil) { paramsCopy["trailingTriggerPrice"] = trailingTriggerPrice }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.createTrailingPercentOrderWs(symbol, typeVar: type, side: side, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createMarketOrderWithCost (symbol: String, side: OrderSide, cost: Double, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.createMarketOrder(withCost: symbol, side: side, cost: cost, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createMarketBuyOrderWithCost (symbol: String, cost: Double, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.createMarketBuyOrder(withCost: symbol, cost: cost, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createMarketSellOrderWithCost (symbol: String, cost: Double, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.createMarketSellOrder(withCost: symbol, cost: cost, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createMarketOrderWithCostWs (symbol: String, side: OrderSide, cost: Double, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.createMarketOrder(withCostWs: symbol, side: side, cost: cost, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createTriggerOrder (symbol: String, type: OrderType, side: OrderSide, amount: Double, price: Double? = nil, triggerPrice: Double? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (price != nil) { paramsCopy["price"] = price }
					if (triggerPrice != nil) { paramsCopy["triggerPrice"] = triggerPrice }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.createTriggerOrder(symbol, typeVar: type, side: side, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createTriggerOrderWs (symbol: String, type: OrderType, side: OrderSide, amount: Double, price: Double? = nil, triggerPrice: Double? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (price != nil) { paramsCopy["price"] = price }
					if (triggerPrice != nil) { paramsCopy["triggerPrice"] = triggerPrice }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.createTriggerOrderWs(symbol, typeVar: type, side: side, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createStopLossOrder (symbol: String, type: OrderType, side: OrderSide, amount: Double, price: Double? = nil, stopLossPrice: Double? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (price != nil) { paramsCopy["price"] = price }
					if (stopLossPrice != nil) { paramsCopy["stopLossPrice"] = stopLossPrice }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.createStopLossOrder(symbol, typeVar: type, side: side, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createStopLossOrderWs (symbol: String, type: OrderType, side: OrderSide, amount: Double, price: Double? = nil, stopLossPrice: Double? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (price != nil) { paramsCopy["price"] = price }
					if (stopLossPrice != nil) { paramsCopy["stopLossPrice"] = stopLossPrice }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.createStopLossOrderWs(symbol, typeVar: type, side: side, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createTakeProfitOrder (symbol: String, type: OrderType, side: OrderSide, amount: Double, price: Double? = nil, takeProfitPrice: Double? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (price != nil) { paramsCopy["price"] = price }
					if (takeProfitPrice != nil) { paramsCopy["takeProfitPrice"] = takeProfitPrice }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.createTakeProfitOrder(symbol, typeVar: type, side: side, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createTakeProfitOrderWs (symbol: String, type: OrderType, side: OrderSide, amount: Double, price: Double? = nil, takeProfitPrice: Double? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (price != nil) { paramsCopy["price"] = price }
					if (takeProfitPrice != nil) { paramsCopy["takeProfitPrice"] = takeProfitPrice }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.createTakeProfitOrderWs(symbol, typeVar: type, side: side, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createOrderWithTakeProfitAndStopLoss (symbol: String, type: OrderType, side: OrderSide, amount: Double, price: Double? = nil, takeProfit: Double? = nil, stopLoss: Double? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (price != nil) { paramsCopy["price"] = price }
					if (takeProfit != nil) { paramsCopy["takeProfit"] = takeProfit }
					if (stopLoss != nil) { paramsCopy["stopLoss"] = stopLoss }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.createOrder(withTakeProfitAndStopLoss: symbol, typeVar: type, side: side, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createOrderWithTakeProfitAndStopLossWs (symbol: String, type: OrderType, side: OrderSide, amount: Double, price: Double? = nil, takeProfit: Double? = nil, stopLoss: Double? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (price != nil) { paramsCopy["price"] = price }
					if (takeProfit != nil) { paramsCopy["takeProfit"] = takeProfit }
					if (stopLoss != nil) { paramsCopy["stopLoss"] = stopLoss }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.createOrder(withTakeProfitAndStopLossWs: symbol, typeVar: type, side: side, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createOrderWs (symbol: String, type: OrderType, side: OrderSide, amount: Double, price: Double? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (price != nil) { paramsCopy["price"] = price }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.createOrderWs(symbol, typeVar: type, side: side, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func cancelOrder (id: String, symbol: String? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.cancelOrder(id, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func cancelOrderWs (id: String, symbol: String? = nil, params: [String: Any] = [:]) async throws -> Any {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Any, Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.cancelOrderWs(id, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! Any)
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func cancelOrdersWs (ids: [String], symbol: String? = nil, params: [String: Any] = [:]) async throws -> Any {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Any, Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
					let ids_string = ids.joined(separator: ",")
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.cancelOrdersWs(ids_string, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! Any)
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func cancelAllOrders (symbol: String? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.cancelAllOrders(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func cancelAllOrdersWs (symbol: String? = nil, params: [String: Any] = [:]) async throws -> Any {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Any, Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.cancelAllOrdersWs(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! Any)
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchOrders (symbol: String? = nil, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchOrders(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchOrdersWs (symbol: String? = nil, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchOrdersWs(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchOrderTrades (id: String, symbol: String? = nil, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchOrderTrades(id, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func watchOrders (symbol: String? = nil, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.watchOrders(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchOpenOrders (symbol: String? = nil, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchOpenOrders(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchOpenOrdersWs (symbol: String? = nil, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchOpenOrdersWs(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchClosedOrders (symbol: String? = nil, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchClosedOrders(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchCanceledAndClosedOrders (symbol: String? = nil, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchCanceledAndClosedOrders(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchClosedOrdersWs (symbol: String? = nil, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchClosedOrdersWs(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchMyTrades (symbol: String? = nil, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchMyTrades(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchMyLiquidations (symbol: String? = nil, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchMyLiquidations(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchLiquidations (symbol: String, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchLiquidations(symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchMyTradesWs (symbol: String? = nil, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchMyTradesWs(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func watchMyTrades (symbol: String? = nil, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.watchMyTrades(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchGreeks (symbol: String, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchGreeks(symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchOptionChain (code: String, params: [String: Any] = [:]) async throws -> [String: [String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: [String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchOptionChain(code, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: [String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchOption (symbol: String, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchOption(symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchConvertQuote (fromCode: String, toCode: String, amount: Double? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (amount != nil) { paramsCopy["amount"] = amount }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchConvertQuote(fromCode, toCode: toCode, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchDepositsWithdrawals (code: String? = nil, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (code != nil) { paramsCopy["code"] = code }
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchDepositsWithdrawals(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchDeposits (code: String? = nil, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (code != nil) { paramsCopy["code"] = code }
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchDeposits(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchWithdrawals (code: String? = nil, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (code != nil) { paramsCopy["code"] = code }
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchWithdrawals(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchDepositsWs (code: String? = nil, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> Any {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Any, Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (code != nil) { paramsCopy["code"] = code }
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchDepositsWs(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! Any)
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchWithdrawalsWs (code: String? = nil, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> Any {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Any, Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (code != nil) { paramsCopy["code"] = code }
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchWithdrawalsWs(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! Any)
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchFundingRateHistory (symbol: String? = nil, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchFundingRateHistory(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchFundingHistory (symbol: String? = nil, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbol != nil) { paramsCopy["symbol"] = symbol }
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchFundingHistory(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func closePosition (symbol: String, side: OrderSide = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (side != nil) { paramsCopy["side"] = side }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.closePosition(symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func closeAllPositions (params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.closeAllPositions(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchL3OrderBook (symbol: String, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchL3OrderBook(symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchDepositAddress (code: String, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchDepositAddress(code, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createLimitOrder (symbol: String, side: OrderSide, amount: Double, price: Double, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.createLimitOrder(symbol, side: side, amount: amount, price: price, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createLimitOrderWs (symbol: String, side: OrderSide, amount: Double, price: Double, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.createLimitOrderWs(symbol, side: side, amount: amount, price: price, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createMarketOrder (symbol: String, side: OrderSide, amount: Double, price: Double? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (price != nil) { paramsCopy["price"] = price }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.createMarketOrder(symbol, side: side, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createMarketOrderWs (symbol: String, side: OrderSide, amount: Double, price: Double? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (price != nil) { paramsCopy["price"] = price }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.createMarketOrderWs(symbol, side: side, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createLimitBuyOrder (symbol: String, amount: Double, price: Double, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.createLimitBuyOrder(symbol, amount: amount, price: price, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createLimitBuyOrderWs (symbol: String, amount: Double, price: Double, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.createLimitBuyOrderWs(symbol, amount: amount, price: price, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createLimitSellOrder (symbol: String, amount: Double, price: Double, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.createLimitSellOrder(symbol, amount: amount, price: price, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createLimitSellOrderWs (symbol: String, amount: Double, price: Double, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.createLimitSellOrderWs(symbol, amount: amount, price: price, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createMarketBuyOrder (symbol: String, amount: Double, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.createMarketBuyOrder(symbol, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createMarketBuyOrderWs (symbol: String, amount: Double, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.createMarketBuyOrderWs(symbol, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createMarketSellOrder (symbol: String, amount: Double, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.createMarketSellOrder(symbol, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createMarketSellOrderWs (symbol: String, amount: Double, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.createMarketSellOrderWs(symbol, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchMarketLeverageTiers (symbol: String, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchMarketLeverageTiers(symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createPostOnlyOrder (symbol: String, type: OrderType, side: OrderSide, amount: Double, price: Double? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (price != nil) { paramsCopy["price"] = price }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.createPostOnlyOrder(symbol, typeVar: type, side: side, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createPostOnlyOrderWs (symbol: String, type: OrderType, side: OrderSide, amount: Double, price: Double? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (price != nil) { paramsCopy["price"] = price }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.createPostOnlyOrderWs(symbol, typeVar: type, side: side, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createReduceOnlyOrder (symbol: String, type: OrderType, side: OrderSide, amount: Double, price: Double? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (price != nil) { paramsCopy["price"] = price }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.createReduceOnlyOrder(symbol, typeVar: type, side: side, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createReduceOnlyOrderWs (symbol: String, type: OrderType, side: OrderSide, amount: Double, price: Double? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (price != nil) { paramsCopy["price"] = price }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.createReduceOnlyOrderWs(symbol, typeVar: type, side: side, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createStopOrder (symbol: String, type: OrderType, side: OrderSide, amount: Double, price: Double? = nil, triggerPrice: Double? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (price != nil) { paramsCopy["price"] = price }
					if (triggerPrice != nil) { paramsCopy["triggerPrice"] = triggerPrice }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.createStopOrder(symbol, typeVar: type, side: side, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createStopOrderWs (symbol: String, type: OrderType, side: OrderSide, amount: Double, price: Double? = nil, triggerPrice: Double? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (price != nil) { paramsCopy["price"] = price }
					if (triggerPrice != nil) { paramsCopy["triggerPrice"] = triggerPrice }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.createStopOrderWs(symbol, typeVar: type, side: side, amount: amount, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createStopLimitOrder (symbol: String, side: OrderSide, amount: Double, price: Double, triggerPrice: Double, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.createStopLimitOrder(symbol, side: side, amount: amount, price: price, triggerPrice: triggerPrice, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createStopLimitOrderWs (symbol: String, side: OrderSide, amount: Double, price: Double, triggerPrice: Double, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.createStopLimitOrderWs(symbol, side: side, amount: amount, price: price, triggerPrice: triggerPrice, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createStopMarketOrder (symbol: String, side: OrderSide, amount: Double, triggerPrice: Double, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.createStopMarketOrder(symbol, side: side, amount: amount, triggerPrice: triggerPrice, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func createStopMarketOrderWs (symbol: String, side: OrderSide, amount: Double, triggerPrice: Double, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.createStopMarketOrderWs(symbol, side: side, amount: amount, triggerPrice: triggerPrice, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchLastPrices (symbols: Strings = nil, params: [String: Any] = [:]) async throws -> [String: [String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: [String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbols != nil) { paramsCopy["symbols"] = symbols }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchLastPrices(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: [String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchTradingFees (params: [String: Any] = [:]) async throws -> [String: [String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: [String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchTradingFees(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: [String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchTradingFeesWs (params: [String: Any] = [:]) async throws -> [String: [String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: [String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchTradingFeesWs(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: [String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchTradingFee (symbol: String, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchTradingFee(symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchConvertCurrencies (params: [String: Any] = [:]) async throws -> [String: [String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: [String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchConvertCurrencies(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: [String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchFundingRate (symbol: String, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchFundingRate(symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchFundingInterval (symbol: String, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let paramsData = try? JSONSerialization.data(withJSONObject: params)
                    let data = try self.exchange.fetchFundingInterval(symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchMarkOHLCV (symbol: String, timeframe: String = "1m", since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[Double]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[Double]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchMarkOHLCV(symbol, timeframe: timeframe, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[Double]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchIndexOHLCV (symbol: String, timeframe: String = "1m", since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[Double]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[Double]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchIndexOHLCV(symbol, timeframe: timeframe, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[Double]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchPremiumIndexOHLCV (symbol: String, timeframe: String = "1m", since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[Double]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[Double]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchPremiumIndexOHLCV(symbol, timeframe: timeframe, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[Double]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchTransactions (code: String? = nil, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (code != nil) { paramsCopy["code"] = code }
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchTransactions(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchPositionHistory (symbol: String, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchPositionHistory(symbol, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchPositionsHistory (symbols: Strings = nil, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (symbols != nil) { paramsCopy["symbols"] = symbols }
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchPositionsHistory(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchTransfer (id: String, code: String? = nil, params: [String: Any] = [:]) async throws -> [String: Any] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[String: Any], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (code != nil) { paramsCopy["code"] = code }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchTransfer(id, params: paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [String: Any])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


    public func fetchTransfers (code: String? = nil, since: Int? = nil, limit: Int? = nil, params: [String: Any] = [:]) async throws -> [[String: Any]] {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<[[String: Any]], Error>) in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
					var paramsCopy: [String: Any] = params
					if (code != nil) { paramsCopy["code"] = code }
					if (since != nil) { paramsCopy["since"] = since }
					if (limit != nil) { paramsCopy["limit"] = limit }
                    let paramsData = try? JSONSerialization.data(withJSONObject: paramsCopy)
                    let data = try self.exchange.fetchTransfers(paramsData)
                    do {
                        let jsonObject = try self.decode(data)
                        let cleaned = self.cleanAny(jsonObject)
                        continuation.resume(returning: cleaned as! [[String: Any]])
                    } catch {
                        continuation.resume(throwing: error)
                    }
                } catch {
                    continuation.resume(throwing: error)
                }
            }
        }
    }


}
